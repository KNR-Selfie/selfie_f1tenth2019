#!/usr/bin/env python

import rospy
import copy
import math

from geometry_msgs.msg import Point, PoseStamped, PoseWithCovarianceStamped
from visualization_msgs.msg import Marker, InteractiveMarker, InteractiveMarkerControl

from interactive_markers.interactive_marker_server import InteractiveMarkerServer, InteractiveMarkerFeedback

START_AREA_WIDTH = 0.1

def move_first(feedback):
    global a
    a = (feedback.pose.position.x, feedback.pose.position.y)
    calculate_start_area()

def move_second(feedback):
    global b
    b = (feedback.pose.position.x, feedback.pose.position.y)
    calculate_start_area()

def calculate_start_area():
    # Normal vector
    global n_x, n_y
    n_x = a[1] - b[1] 
    n_y = b[0] - a[0] 
    n_x = n_x / (n_x**2 + n_y**2)
    n_y = n_y / (n_x**2 + n_y**2)

     # Find opposite corners of the start area
    global c_1, c_2
    v = (n_x * START_AREA_WIDTH, n_y * START_AREA_WIDTH)
    c_1 = (a[0] - v[0], a[1] - v[1])
    c_2 = (b[0] + v[0], b[1] + v[1])

def make_sphere(msg):
    marker = Marker()

    marker.type = Marker.SPHERE
    marker.scale.x = msg.scale
    marker.scale.y = msg.scale
    marker.scale.z = msg.scale
    marker.color.r = 0.0
    marker.color.g = 1.0 
    marker.color.b = 0.0
    marker.color.a = 1.0

    return marker

def make_waypoint_marker(id, x, y):
    int_marker = InteractiveMarker()
    int_marker.header.frame_id = 'map'
    int_marker.pose.position = Point(x, y, 0)
    int_marker.scale = 0.1

    int_marker.name = 'waypoint_' + str(id)

    control = InteractiveMarkerControl()
    control.orientation.w = 1
    control.orientation.x = 0
    control.orientation.y = 1
    control.orientation.z = 0
    control.interaction_mode = InteractiveMarkerControl.MOVE_PLANE
    int_marker.controls.append(copy.deepcopy(control))

    control.markers.append( make_sphere(int_marker) )
    control.always_visible = True
    int_marker.controls.append(control)

    return int_marker

def publish_markers():
    marker_server.clear()

    global a, b
    a = (0, 0)
    b = (0, 1)

    marker = make_waypoint_marker('a', a[0], a[1])
    marker_server.insert(marker, move_first)

    marker = make_waypoint_marker('b', b[0], b[1])
    marker_server.insert(marker, move_second)

    marker_server.applyChanges()
    calculate_start_area()

def pose_callback(msg):
    delta = math.atan2(n_y, n_x)

    theta_1 = math.atan2(msg.pose.pose.position.y - c_1[1],
                         msg.pose.pose.position.x - c_1[0])

    theta_2 = math.atan2(msg.pose.pose.position.y - c_2[1],
                         msg.pose.pose.position.x - c_2[0])
 
    theta_1 -= delta
    if theta_1 < -math.pi:
        theta_1 += 2*math.pi
    if theta_1 > math.pi:
        theta_1 -= 2*math.pi

    theta_2 -= delta
    if theta_2 < -math.pi:
        theta_2 += 2*math.pi
    if theta_2 > math.pi:
        theta_2 -= 2*math.pi

    global inside_start_area
    if -math.pi/2 <= theta_1 and theta_1 <= 0 and \
        math.pi/2 <= theta_2 and theta_2 <= math.pi:
 
        inside_start_area = True
    else:
        if inside_start_area: starting_line_crossed() 
        inside_start_area = False
        
def starting_line_crossed():
    rospy.loginfo('Starting line crossed')
    current_time = rospy.get_rostime()

    global time_left_start_area
    if time_left_start_area is not None:
        time_delta = current_time - time_left_start_area
        rospy.loginfo('LAP TIME: {:6.3f}s'.format(time_delta.to_sec()))
 
    time_left_start_area = current_time

if __name__ == '__main__':
    rospy.init_node('laptime_measurer')

    global marker_server
    marker_server = InteractiveMarkerServer('laptime_measurer_server')

    publish_markers()

    global inside_start_area
    inside_start_area = False

    global time_left_start_area
    time_left_start_area = None

    rospy.Subscriber('amcl_pose', PoseWithCovarianceStamped, pose_callback)

    rospy.spin()
